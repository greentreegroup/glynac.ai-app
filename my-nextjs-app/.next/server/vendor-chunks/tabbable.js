"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tabbable";
exports.ids = ["vendor-chunks/tabbable"];
exports.modules = {

/***/ "(ssr)/../node_modules/tabbable/dist/index.esm.js":
/*!**************************************************!*\
  !*** ../node_modules/tabbable/dist/index.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   focusable: () => (/* binding */ focusable),\n/* harmony export */   getTabIndex: () => (/* binding */ getTabIndex),\n/* harmony export */   isFocusable: () => (/* binding */ isFocusable),\n/* harmony export */   isTabbable: () => (/* binding */ isTabbable),\n/* harmony export */   tabbable: () => (/* binding */ tabbable)\n/* harmony export */ });\n/*!\r\n* tabbable 6.2.0\r\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\r\n*/\r\n// NOTE: separate `:not()` selectors has broader browser support than the newer\r\n//  `:not([inert], [inert] *)` (Feb 2023)\r\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\r\n//  the entire query to fail, resulting in no nodes found, which will break a lot\r\n//  of things... so we have to rely on JS to identify nodes inside an inert container\r\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\r\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\r\nvar NoElement = typeof Element === 'undefined';\r\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\r\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\r\n  var _element$getRootNode;\r\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\r\n} : function (element) {\r\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\r\n};\r\n\r\n/**\r\n * Determines if a node is inert or in an inert ancestor.\r\n * @param {Element} [node]\r\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\r\n *  see if any of them are inert. If false, only `node` itself is considered.\r\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\r\n *  False if `node` is falsy.\r\n */\r\nvar isInert = function isInert(node, lookUp) {\r\n  var _node$getAttribute;\r\n  if (lookUp === void 0) {\r\n    lookUp = true;\r\n  }\r\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\r\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\r\n  //  if it's `null` (not specified) or 'false', it's an active element\r\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\r\n  var inert = inertAtt === '' || inertAtt === 'true';\r\n\r\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\r\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\r\n  //  code works for any kind of node\r\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\r\n  //  so it likely would not support `:is([inert] *)` either...\r\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Determines if a node's content is editable.\r\n * @param {Element} [node]\r\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\r\n */\r\nvar isContentEditable = function isContentEditable(node) {\r\n  var _node$getAttribute2;\r\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\r\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\r\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\r\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\r\n  return attValue === '' || attValue === 'true';\r\n};\r\n\r\n/**\r\n * @param {Element} el container to check in\r\n * @param {boolean} includeContainer add container to check\r\n * @param {(node: Element) => boolean} filter filter candidates\r\n * @returns {Element[]}\r\n */\r\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\r\n  // even if `includeContainer=false`, we still have to check it for inertness because\r\n  //  if it's inert, all its children are inert\r\n  if (isInert(el)) {\r\n    return [];\r\n  }\r\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\r\n  if (includeContainer && matches.call(el, candidateSelector)) {\r\n    candidates.unshift(el);\r\n  }\r\n  candidates = candidates.filter(filter);\r\n  return candidates;\r\n};\r\n\r\n/**\r\n * @callback GetShadowRoot\r\n * @param {Element} element to check for shadow root\r\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\r\n */\r\n\r\n/**\r\n * @callback ShadowRootFilter\r\n * @param {Element} shadowHostNode the element which contains shadow content\r\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\r\n */\r\n\r\n/**\r\n * @typedef {Object} CandidateScope\r\n * @property {Element} scopeParent contains inner candidates\r\n * @property {Element[]} candidates list of candidates found in the scope parent\r\n */\r\n\r\n/**\r\n * @typedef {Object} IterativeOptions\r\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\r\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\r\n *  or a boolean stating if it has an undisclosed shadow root\r\n * @property {(node: Element) => boolean} filter filter candidates\r\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\r\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\r\n */\r\n\r\n/**\r\n * @param {Element[]} elements list of element containers to match candidates from\r\n * @param {boolean} includeContainer add container list to check\r\n * @param {IterativeOptions} options\r\n * @returns {Array.<Element|CandidateScope>}\r\n */\r\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\r\n  var candidates = [];\r\n  var elementsToCheck = Array.from(elements);\r\n  while (elementsToCheck.length) {\r\n    var element = elementsToCheck.shift();\r\n    if (isInert(element, false)) {\r\n      // no need to look up since we're drilling down\r\n      // anything inside this container will also be inert\r\n      continue;\r\n    }\r\n    if (element.tagName === 'SLOT') {\r\n      // add shadow dom slot scope (slot itself cannot be focusable)\r\n      var assigned = element.assignedElements();\r\n      var content = assigned.length ? assigned : element.children;\r\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\r\n      if (options.flatten) {\r\n        candidates.push.apply(candidates, nestedCandidates);\r\n      } else {\r\n        candidates.push({\r\n          scopeParent: element,\r\n          candidates: nestedCandidates\r\n        });\r\n      }\r\n    } else {\r\n      // check candidate element\r\n      var validCandidate = matches.call(element, candidateSelector);\r\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\r\n        candidates.push(element);\r\n      }\r\n\r\n      // iterate over shadow content if possible\r\n      var shadowRoot = element.shadowRoot ||\r\n      // check for an undisclosed shadow\r\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\r\n\r\n      // no inert look up because we're already drilling down and checking for inertness\r\n      //  on the way down, so all containers to this root node should have already been\r\n      //  vetted as non-inert\r\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\r\n      if (shadowRoot && validShadowRoot) {\r\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\r\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\r\n        //  child candidates found because they're likely slotted elements (elements that are\r\n        //  children of the web component element (which has the shadow), in the light dom, but\r\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\r\n        //  _after_ we return from this recursive call\r\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\r\n        if (options.flatten) {\r\n          candidates.push.apply(candidates, _nestedCandidates);\r\n        } else {\r\n          candidates.push({\r\n            scopeParent: element,\r\n            candidates: _nestedCandidates\r\n          });\r\n        }\r\n      } else {\r\n        // there's not shadow so just dig into the element's (light dom) children\r\n        //  __without__ giving the element special scope treatment\r\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\r\n      }\r\n    }\r\n  }\r\n  return candidates;\r\n};\r\n\r\n/**\r\n * @private\r\n * Determines if the node has an explicitly specified `tabindex` attribute.\r\n * @param {HTMLElement} node\r\n * @returns {boolean} True if so; false if not.\r\n */\r\nvar hasTabIndex = function hasTabIndex(node) {\r\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\r\n};\r\n\r\n/**\r\n * Determine the tab index of a given node.\r\n * @param {HTMLElement} node\r\n * @returns {number} Tab order (negative, 0, or positive number).\r\n * @throws {Error} If `node` is falsy.\r\n */\r\nvar getTabIndex = function getTabIndex(node) {\r\n  if (!node) {\r\n    throw new Error('No node provided');\r\n  }\r\n  if (node.tabIndex < 0) {\r\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\r\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\r\n    // yet they are still part of the regular tab order; in FF, they get a default\r\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\r\n    // order, consider their tab index to be 0.\r\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\r\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\r\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\r\n      return 0;\r\n    }\r\n  }\r\n  return node.tabIndex;\r\n};\r\n\r\n/**\r\n * Determine the tab index of a given node __for sort order purposes__.\r\n * @param {HTMLElement} node\r\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\r\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\r\n *  inserted into the correct sort position.\r\n * @returns {number} Tab order (negative, 0, or positive number).\r\n */\r\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\r\n  var tabIndex = getTabIndex(node);\r\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\r\n    return 0;\r\n  }\r\n  return tabIndex;\r\n};\r\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\r\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\r\n};\r\nvar isInput = function isInput(node) {\r\n  return node.tagName === 'INPUT';\r\n};\r\nvar isHiddenInput = function isHiddenInput(node) {\r\n  return isInput(node) && node.type === 'hidden';\r\n};\r\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\r\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\r\n    return child.tagName === 'SUMMARY';\r\n  });\r\n  return r;\r\n};\r\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    if (nodes[i].checked && nodes[i].form === form) {\r\n      return nodes[i];\r\n    }\r\n  }\r\n};\r\nvar isTabbableRadio = function isTabbableRadio(node) {\r\n  if (!node.name) {\r\n    return true;\r\n  }\r\n  var radioScope = node.form || getRootNode(node);\r\n  var queryRadios = function queryRadios(name) {\r\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\r\n  };\r\n  var radioSet;\r\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\r\n    radioSet = queryRadios(window.CSS.escape(node.name));\r\n  } else {\r\n    try {\r\n      radioSet = queryRadios(node.name);\r\n    } catch (err) {\r\n      // eslint-disable-next-line no-console\r\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\r\n      return false;\r\n    }\r\n  }\r\n  var checked = getCheckedRadio(radioSet, node.form);\r\n  return !checked || checked === node;\r\n};\r\nvar isRadio = function isRadio(node) {\r\n  return isInput(node) && node.type === 'radio';\r\n};\r\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\r\n  return isRadio(node) && !isTabbableRadio(node);\r\n};\r\n\r\n// determines if a node is ultimately attached to the window's document\r\nvar isNodeAttached = function isNodeAttached(node) {\r\n  var _nodeRoot;\r\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\r\n  //  (but NOT _the_ document; see second 'If' comment below for more).\r\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\r\n  //  is attached, and the one we need to check if it's in the document or not (because the\r\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\r\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\r\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\r\n  //  visibility, including all the nodes it contains). The host could be any normal node,\r\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\r\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\r\n  //  tested).\r\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\r\n  //  that is attached (or find none) because the node might be in nested shadows...\r\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\r\n  //  document (per the docs) and while it's a Document-type object, that document does not\r\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\r\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\r\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\r\n  //  node is actually detached.\r\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\r\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\r\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\r\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\r\n  var nodeRoot = node && getRootNode(node);\r\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\r\n\r\n  // in some cases, a detached node will return itself as the root instead of a document or\r\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\r\n  var attached = false;\r\n  if (nodeRoot && nodeRoot !== node) {\r\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\r\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\r\n    while (!attached && nodeRootHost) {\r\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\r\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\r\n      //  which means we need to get the host's host and check if that parent host is contained\r\n      //  in (i.e. attached to) the document\r\n      nodeRoot = getRootNode(nodeRootHost);\r\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\r\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\r\n    }\r\n  }\r\n  return attached;\r\n};\r\nvar isZeroArea = function isZeroArea(node) {\r\n  var _node$getBoundingClie = node.getBoundingClientRect(),\r\n    width = _node$getBoundingClie.width,\r\n    height = _node$getBoundingClie.height;\r\n  return width === 0 && height === 0;\r\n};\r\nvar isHidden = function isHidden(node, _ref) {\r\n  var displayCheck = _ref.displayCheck,\r\n    getShadowRoot = _ref.getShadowRoot;\r\n  // NOTE: visibility will be `undefined` if node is detached from the document\r\n  //  (see notes about this further down), which means we will consider it visible\r\n  //  (this is legacy behavior from a very long way back)\r\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\r\n  //  _visibility_ check, not a _display_ check\r\n  if (getComputedStyle(node).visibility === 'hidden') {\r\n    return true;\r\n  }\r\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\r\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\r\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\r\n    return true;\r\n  }\r\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\r\n    if (typeof getShadowRoot === 'function') {\r\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\r\n      //  'non-zero-area' fallback\r\n      var originalNode = node;\r\n      while (node) {\r\n        var parentElement = node.parentElement;\r\n        var rootNode = getRootNode(node);\r\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\r\n        ) {\r\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\r\n          //  fall back to a non-zero-area test\r\n          return isZeroArea(node);\r\n        } else if (node.assignedSlot) {\r\n          // iterate up slot\r\n          node = node.assignedSlot;\r\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\r\n          // cross shadow boundary\r\n          node = rootNode.host;\r\n        } else {\r\n          // iterate up normal dom\r\n          node = parentElement;\r\n        }\r\n      }\r\n      node = originalNode;\r\n    }\r\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\r\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\r\n    //  it might be a falsy value, which means shadow DOM support is disabled\r\n\r\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\r\n    //  now we can just test to see if it would normally be visible or not, provided it's\r\n    //  attached to the main document.\r\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\r\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\r\n\r\n    if (isNodeAttached(node)) {\r\n      // this works wherever the node is: if there's at least one client rect, it's\r\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\r\n      //  node itself is hidden in place of its contents; and there's no need to search\r\n      //  up the hierarchy either\r\n      return !node.getClientRects().length;\r\n    }\r\n\r\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\r\n    //  API will __always__ return zero rects (this can happen, for example, if React\r\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\r\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\r\n    //\r\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\r\n    //  because styles are only computed for nodes that are in the document.\r\n    //\r\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\r\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\r\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\r\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\r\n    //  considering __everything__ to be visible because of the innability to determine styles.\r\n    //\r\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\r\n    //  nodes as visible with the 'none' fallback.__\r\n    if (displayCheck !== 'legacy-full') {\r\n      return true; // hidden\r\n    }\r\n    // else, fallback to 'none' mode and consider the node visible\r\n  } else if (displayCheck === 'non-zero-area') {\r\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\r\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\r\n    //  client rect, we don't special-case for whether the node is attached or not. In\r\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\r\n    //  times, and that includes attached or not.\r\n    return isZeroArea(node);\r\n  }\r\n\r\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\r\n  //  it's visible\r\n  return false;\r\n};\r\n\r\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\r\n//  unless they are in the _first_ <legend> element of the top-most disabled\r\n//  fieldset\r\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\r\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\r\n    var parentNode = node.parentElement;\r\n    // check if `node` is contained in a disabled <fieldset>\r\n    while (parentNode) {\r\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\r\n        // look for the first <legend> among the children of the disabled <fieldset>\r\n        for (var i = 0; i < parentNode.children.length; i++) {\r\n          var child = parentNode.children.item(i);\r\n          // when the first <legend> (in document order) is found\r\n          if (child.tagName === 'LEGEND') {\r\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\r\n            // return whether `node` is a descendant of its first <legend>\r\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\r\n          }\r\n        }\r\n        // the disabled <fieldset> containing `node` has no <legend>\r\n        return true;\r\n      }\r\n      parentNode = parentNode.parentElement;\r\n    }\r\n  }\r\n\r\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\r\n  //  enabled/disabled state\r\n  return false;\r\n};\r\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\r\n  if (node.disabled ||\r\n  // we must do an inert look up to filter out any elements inside an inert ancestor\r\n  //  because we're limited in the type of selectors we can use in JSDom (see related\r\n  //  note related to `candidateSelectors`)\r\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\r\n  // For a details element with a summary, the summary element gets the focus\r\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\r\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\r\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\r\n  if (isNaN(tabIndex) || tabIndex >= 0) {\r\n    return true;\r\n  }\r\n  // If a custom element has an explicit negative tabindex,\r\n  // browsers will not allow tab targeting said element's children.\r\n  return false;\r\n};\r\n\r\n/**\r\n * @param {Array.<Element|CandidateScope>} candidates\r\n * @returns Element[]\r\n */\r\nvar sortByOrder = function sortByOrder(candidates) {\r\n  var regularTabbables = [];\r\n  var orderedTabbables = [];\r\n  candidates.forEach(function (item, i) {\r\n    var isScope = !!item.scopeParent;\r\n    var element = isScope ? item.scopeParent : item;\r\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\r\n    var elements = isScope ? sortByOrder(item.candidates) : element;\r\n    if (candidateTabindex === 0) {\r\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\r\n    } else {\r\n      orderedTabbables.push({\r\n        documentOrder: i,\r\n        tabIndex: candidateTabindex,\r\n        item: item,\r\n        isScope: isScope,\r\n        content: elements\r\n      });\r\n    }\r\n  });\r\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\r\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\r\n    return acc;\r\n  }, []).concat(regularTabbables);\r\n};\r\nvar tabbable = function tabbable(container, options) {\r\n  options = options || {};\r\n  var candidates;\r\n  if (options.getShadowRoot) {\r\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\r\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\r\n      flatten: false,\r\n      getShadowRoot: options.getShadowRoot,\r\n      shadowRootFilter: isValidShadowRootTabbable\r\n    });\r\n  } else {\r\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\r\n  }\r\n  return sortByOrder(candidates);\r\n};\r\nvar focusable = function focusable(container, options) {\r\n  options = options || {};\r\n  var candidates;\r\n  if (options.getShadowRoot) {\r\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\r\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\r\n      flatten: true,\r\n      getShadowRoot: options.getShadowRoot\r\n    });\r\n  } else {\r\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\r\n  }\r\n  return candidates;\r\n};\r\nvar isTabbable = function isTabbable(node, options) {\r\n  options = options || {};\r\n  if (!node) {\r\n    throw new Error('No node provided');\r\n  }\r\n  if (matches.call(node, candidateSelector) === false) {\r\n    return false;\r\n  }\r\n  return isNodeMatchingSelectorTabbable(options, node);\r\n};\r\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\r\nvar isFocusable = function isFocusable(node, options) {\r\n  options = options || {};\r\n  if (!node) {\r\n    throw new Error('No node provided');\r\n  }\r\n  if (matches.call(node, focusableCandidateSelector) === false) {\r\n    return false;\r\n  }\r\n  return isNodeMatchingSelectorFocusable(options, node);\r\n};\r\n\r\n\r\n//# sourceMappingURL=index.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLDRCQUE0QjtBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QixjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsdUJBQXVCLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYyxTQUFT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ZXMiOlsiQzpcXFVzZXJzXFx1c2VyXFxEb3dubG9hZHNcXGdseW5hYy5haS13ZWJzaXRlXFxub2RlX21vZHVsZXNcXHRhYmJhYmxlXFxkaXN0XFxpbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiogdGFiYmFibGUgNi4yLjBcclxuKiBAbGljZW5zZSBNSVQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL3RhYmJhYmxlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuKi9cclxuLy8gTk9URTogc2VwYXJhdGUgYDpub3QoKWAgc2VsZWN0b3JzIGhhcyBicm9hZGVyIGJyb3dzZXIgc3VwcG9ydCB0aGFuIHRoZSBuZXdlclxyXG4vLyAgYDpub3QoW2luZXJ0XSwgW2luZXJ0XSAqKWAgKEZlYiAyMDIzKVxyXG4vLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBzdXBwb3J0IGA6bm90KFtpbmVydF0gKilgIGFzIGEgc2VsZWN0b3I7IHVzaW5nIGl0IGNhdXNlc1xyXG4vLyAgdGhlIGVudGlyZSBxdWVyeSB0byBmYWlsLCByZXN1bHRpbmcgaW4gbm8gbm9kZXMgZm91bmQsIHdoaWNoIHdpbGwgYnJlYWsgYSBsb3RcclxuLy8gIG9mIHRoaW5ncy4uLiBzbyB3ZSBoYXZlIHRvIHJlbHkgb24gSlMgdG8gaWRlbnRpZnkgbm9kZXMgaW5zaWRlIGFuIGluZXJ0IGNvbnRhaW5lclxyXG52YXIgY2FuZGlkYXRlU2VsZWN0b3JzID0gWydpbnB1dDpub3QoW2luZXJ0XSknLCAnc2VsZWN0Om5vdChbaW5lcnRdKScsICd0ZXh0YXJlYTpub3QoW2luZXJ0XSknLCAnYVtocmVmXTpub3QoW2luZXJ0XSknLCAnYnV0dG9uOm5vdChbaW5lcnRdKScsICdbdGFiaW5kZXhdOm5vdChzbG90KTpub3QoW2luZXJ0XSknLCAnYXVkaW9bY29udHJvbHNdOm5vdChbaW5lcnRdKScsICd2aWRlb1tjb250cm9sc106bm90KFtpbmVydF0pJywgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pOm5vdChbaW5lcnRdKScsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZTpub3QoW2luZXJ0XSknLCAnZGV0YWlsczpub3QoW2luZXJ0XSknXTtcclxudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcclxudmFyIE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcclxudmFyIG1hdGNoZXMgPSBOb0VsZW1lbnQgPyBmdW5jdGlvbiAoKSB7fSA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xyXG52YXIgZ2V0Um9vdE5vZGUgPSAhTm9FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlID8gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICB2YXIgX2VsZW1lbnQkZ2V0Um9vdE5vZGU7XHJcbiAgcmV0dXJuIGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9lbGVtZW50JGdldFJvb3ROb2RlID0gZWxlbWVudC5nZXRSb290Tm9kZSkgPT09IG51bGwgfHwgX2VsZW1lbnQkZ2V0Um9vdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbGVtZW50JGdldFJvb3ROb2RlLmNhbGwoZWxlbWVudCk7XHJcbn0gOiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyBpbmVydCBvciBpbiBhbiBpbmVydCBhbmNlc3Rvci5cclxuICogQHBhcmFtIHtFbGVtZW50fSBbbm9kZV1cclxuICogQHBhcmFtIHtib29sZWFufSBbbG9va1VwXSBJZiB0cnVlIGFuZCBgbm9kZWAgaXMgbm90IGluZXJ0LCBsb29rcyB1cCBhdCBhbmNlc3RvcnMgdG9cclxuICogIHNlZSBpZiBhbnkgb2YgdGhlbSBhcmUgaW5lcnQuIElmIGZhbHNlLCBvbmx5IGBub2RlYCBpdHNlbGYgaXMgY29uc2lkZXJlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaW5lcnQgaXRzZWxmIG9yIGJ5IHdheSBvZiBiZWluZyBpbiBhbiBpbmVydCBhbmNlc3Rvci5cclxuICogIEZhbHNlIGlmIGBub2RlYCBpcyBmYWxzeS5cclxuICovXHJcbnZhciBpc0luZXJ0ID0gZnVuY3Rpb24gaXNJbmVydChub2RlLCBsb29rVXApIHtcclxuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xyXG4gIGlmIChsb29rVXAgPT09IHZvaWQgMCkge1xyXG4gICAgbG9va1VwID0gdHJ1ZTtcclxuICB9XHJcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3Qgc3VwcG9ydCBpbmVydCBhdCBhbGwsIHNvIHdlIGNhbid0IHVzZSB0aGUgYEhUTUxFbGVtZW50LmluZXJ0YFxyXG4gIC8vICBKUyBBUEkgcHJvcGVydHk7IHdlIGhhdmUgdG8gY2hlY2sgdGhlIGF0dHJpYnV0ZSwgd2hpY2ggY2FuIGVpdGhlciBiZSBlbXB0eSBvciAndHJ1ZSc7XHJcbiAgLy8gIGlmIGl0J3MgYG51bGxgIChub3Qgc3BlY2lmaWVkKSBvciAnZmFsc2UnLCBpdCdzIGFuIGFjdGl2ZSBlbGVtZW50XHJcbiAgdmFyIGluZXJ0QXR0ID0gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkZ2V0QXR0cmlidXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUpID09PSBudWxsIHx8IF9ub2RlJGdldEF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlLmNhbGwobm9kZSwgJ2luZXJ0Jyk7XHJcbiAgdmFyIGluZXJ0ID0gaW5lcnRBdHQgPT09ICcnIHx8IGluZXJ0QXR0ID09PSAndHJ1ZSc7XHJcblxyXG4gIC8vIE5PVEU6IHRoaXMgY291bGQgYWxzbyBiZSBoYW5kbGVkIHdpdGggYG5vZGUubWF0Y2hlcygnW2luZXJ0XSwgOmlzKFtpbmVydF0gKiknKWBcclxuICAvLyAgaWYgaXQgd2VyZW4ndCBmb3IgYG1hdGNoZXMoKWAgbm90IGJlaW5nIGEgZnVuY3Rpb24gb24gc2hhZG93IHJvb3RzOyB0aGUgZm9sbG93aW5nXHJcbiAgLy8gIGNvZGUgd29ya3MgZm9yIGFueSBraW5kIG9mIG5vZGVcclxuICAvLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBjZXJ0YWluIHNlbGVjdG9ycyBsaWtlIGA6bm90KFtpbmVydF0gKilgXHJcbiAgLy8gIHNvIGl0IGxpa2VseSB3b3VsZCBub3Qgc3VwcG9ydCBgOmlzKFtpbmVydF0gKilgIGVpdGhlci4uLlxyXG4gIHZhciByZXN1bHQgPSBpbmVydCB8fCBsb29rVXAgJiYgbm9kZSAmJiBpc0luZXJ0KG5vZGUucGFyZW50Tm9kZSk7IC8vIHJlY3Vyc2l2ZVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYSBub2RlJ3MgY29udGVudCBpcyBlZGl0YWJsZS5cclxuICogQHBhcmFtIHtFbGVtZW50fSBbbm9kZV1cclxuICogQHJldHVybnMgVHJ1ZSBpZiBpdCdzIGNvbnRlbnQtZWRpdGFibGU7IGZhbHNlIGlmIGl0J3Mgbm90IG9yIGBub2RlYCBpcyBmYWxzeS5cclxuICovXHJcbnZhciBpc0NvbnRlbnRFZGl0YWJsZSA9IGZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKG5vZGUpIHtcclxuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlMjtcclxuICAvLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgSFRNTEVsZW1lbnQuaXNDb250ZW50RWRpdGFibGVgIEFQSSBzbyB3ZSBoYXZlXHJcbiAgLy8gIHRvIHVzZSB0aGUgYXR0cmlidXRlIGRpcmVjdGx5IHRvIGNoZWNrIGZvciB0aGlzLCB3aGljaCBjYW4gZWl0aGVyIGJlIGVtcHR5IG9yICd0cnVlJztcclxuICAvLyAgaWYgaXQncyBgbnVsbGAgKG5vdCBzcGVjaWZpZWQpIG9yICdmYWxzZScsIGl0J3MgYSBub24tZWRpdGFibGUgZWxlbWVudFxyXG4gIHZhciBhdHRWYWx1ZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZTIgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlMi5jYWxsKG5vZGUsICdjb250ZW50ZWRpdGFibGUnKTtcclxuICByZXR1cm4gYXR0VmFsdWUgPT09ICcnIHx8IGF0dFZhbHVlID09PSAndHJ1ZSc7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cclxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcclxuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXHJcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XHJcbiAqL1xyXG52YXIgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIGdldENhbmRpZGF0ZXMoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xyXG4gIC8vIGV2ZW4gaWYgYGluY2x1ZGVDb250YWluZXI9ZmFsc2VgLCB3ZSBzdGlsbCBoYXZlIHRvIGNoZWNrIGl0IGZvciBpbmVydG5lc3MgYmVjYXVzZVxyXG4gIC8vICBpZiBpdCdzIGluZXJ0LCBhbGwgaXRzIGNoaWxkcmVuIGFyZSBpbmVydFxyXG4gIGlmIChpc0luZXJ0KGVsKSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICB2YXIgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKSk7XHJcbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcclxuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XHJcbiAgfVxyXG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xyXG4gIHJldHVybiBjYW5kaWRhdGVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBHZXRTaGFkb3dSb290XHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVjayBmb3Igc2hhZG93IHJvb3RcclxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIFNoYWRvd1Jvb3RGaWx0ZXJcclxuICogQHBhcmFtIHtFbGVtZW50fSBzaGFkb3dIb3N0Tm9kZSB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyBzaGFkb3cgY29udGVudFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gQ2FuZGlkYXRlU2NvcGVcclxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZVBhcmVudCBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXHJcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzIGxpc3Qgb2YgY2FuZGlkYXRlcyBmb3VuZCBpbiB0aGUgc2NvcGUgcGFyZW50XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEl0ZXJhdGl2ZU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XHJcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XHJcbiAqICBvciBhIGJvb2xlYW4gc3RhdGluZyBpZiBpdCBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHJvb3RcclxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxyXG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcclxuICovXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50W119IGVsZW1lbnRzIGxpc3Qgb2YgZWxlbWVudCBjb250YWluZXJzIHRvIG1hdGNoIGNhbmRpZGF0ZXMgZnJvbVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXHJcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlU2NvcGU+fVxyXG4gKi9cclxudmFyIGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseSA9IGZ1bmN0aW9uIGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShlbGVtZW50cywgaW5jbHVkZUNvbnRhaW5lciwgb3B0aW9ucykge1xyXG4gIHZhciBjYW5kaWRhdGVzID0gW107XHJcbiAgdmFyIGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xyXG4gIHdoaWxlIChlbGVtZW50c1RvQ2hlY2subGVuZ3RoKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xyXG4gICAgaWYgKGlzSW5lcnQoZWxlbWVudCwgZmFsc2UpKSB7XHJcbiAgICAgIC8vIG5vIG5lZWQgdG8gbG9vayB1cCBzaW5jZSB3ZSdyZSBkcmlsbGluZyBkb3duXHJcbiAgICAgIC8vIGFueXRoaW5nIGluc2lkZSB0aGlzIGNvbnRhaW5lciB3aWxsIGFsc28gYmUgaW5lcnRcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcclxuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcclxuICAgICAgdmFyIGFzc2lnbmVkID0gZWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzKCk7XHJcbiAgICAgIHZhciBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xyXG4gICAgICB2YXIgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcclxuICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xyXG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBuZXN0ZWRDYW5kaWRhdGVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xyXG4gICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGNoZWNrIGNhbmRpZGF0ZSBlbGVtZW50XHJcbiAgICAgIHZhciB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XHJcbiAgICAgIGlmICh2YWxpZENhbmRpZGF0ZSAmJiBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJiAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpKSB7XHJcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcclxuICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3QgfHxcclxuICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xyXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KTtcclxuXHJcbiAgICAgIC8vIG5vIGluZXJ0IGxvb2sgdXAgYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IGRyaWxsaW5nIGRvd24gYW5kIGNoZWNraW5nIGZvciBpbmVydG5lc3NcclxuICAgICAgLy8gIG9uIHRoZSB3YXkgZG93biwgc28gYWxsIGNvbnRhaW5lcnMgdG8gdGhpcyByb290IG5vZGUgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuXHJcbiAgICAgIC8vICB2ZXR0ZWQgYXMgbm9uLWluZXJ0XHJcbiAgICAgIHZhciB2YWxpZFNoYWRvd1Jvb3QgPSAhaXNJbmVydChzaGFkb3dSb290LCBmYWxzZSkgJiYgKCFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpKTtcclxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XHJcbiAgICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2NvcGUgSUlGIGEgc2hhZG93IHJvb3Qgbm9kZSB3YXMgZ2l2ZW47IG90aGVyd2lzZSwgYW4gdW5kaXNjbG9zZWRcclxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcclxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXHJcbiAgICAgICAgLy8gIGNoaWxkcmVuIG9mIHRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgKHdoaWNoIGhhcyB0aGUgc2hhZG93KSwgaW4gdGhlIGxpZ2h0IGRvbSwgYnV0XHJcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxyXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcclxuICAgICAgICB2YXIgX25lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLCB0cnVlLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XHJcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2guYXBwbHkoY2FuZGlkYXRlcywgX25lc3RlZENhbmRpZGF0ZXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xyXG4gICAgICAgICAgICBzY29wZVBhcmVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgY2FuZGlkYXRlczogX25lc3RlZENhbmRpZGF0ZXNcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gIF9fd2l0aG91dF9fIGdpdmluZyB0aGUgZWxlbWVudCBzcGVjaWFsIHNjb3BlIHRyZWF0bWVudFxyXG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0LmFwcGx5KGVsZW1lbnRzVG9DaGVjaywgZWxlbWVudC5jaGlsZHJlbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogRGV0ZXJtaW5lcyBpZiB0aGUgbm9kZSBoYXMgYW4gZXhwbGljaXRseSBzcGVjaWZpZWQgYHRhYmluZGV4YCBhdHRyaWJ1dGUuXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgc287IGZhbHNlIGlmIG5vdC5cclxuICovXHJcbnZhciBoYXNUYWJJbmRleCA9IGZ1bmN0aW9uIGhhc1RhYkluZGV4KG5vZGUpIHtcclxuICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgdGFiIGluZGV4IG9mIGEgZ2l2ZW4gbm9kZS5cclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUYWIgb3JkZXIgKG5lZ2F0aXZlLCAwLCBvciBwb3NpdGl2ZSBudW1iZXIpLlxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG5vZGVgIGlzIGZhbHN5LlxyXG4gKi9cclxudmFyIGdldFRhYkluZGV4ID0gZnVuY3Rpb24gZ2V0VGFiSW5kZXgobm9kZSkge1xyXG4gIGlmICghbm9kZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XHJcbiAgfVxyXG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xyXG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxyXG4gICAgLy8gYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcclxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxyXG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcclxuICAgIC8vIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cclxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xyXG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXHJcbiAgICBpZiAoKC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8IGlzQ29udGVudEVkaXRhYmxlKG5vZGUpKSAmJiAhaGFzVGFiSW5kZXgobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgdGFiIGluZGV4IG9mIGEgZ2l2ZW4gbm9kZSBfX2ZvciBzb3J0IG9yZGVyIHB1cnBvc2VzX18uXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcclxuICogQHBhcmFtIHtib29sZWFufSBbaXNTY29wZV0gVHJ1ZSBmb3IgYSBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCwgYnkgZGVmYXVsdCxcclxuICogIGhhcyB0YWJJbmRleCAtMSwgYnV0IG5lZWRzIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgaXRzIGNvbnRlbnQgdG8gYmVcclxuICogIGluc2VydGVkIGludG8gdGhlIGNvcnJlY3Qgc29ydCBwb3NpdGlvbi5cclxuICogQHJldHVybnMge251bWJlcn0gVGFiIG9yZGVyIChuZWdhdGl2ZSwgMCwgb3IgcG9zaXRpdmUgbnVtYmVyKS5cclxuICovXHJcbnZhciBnZXRTb3J0T3JkZXJUYWJJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRPcmRlclRhYkluZGV4KG5vZGUsIGlzU2NvcGUpIHtcclxuICB2YXIgdGFiSW5kZXggPSBnZXRUYWJJbmRleChub2RlKTtcclxuICBpZiAodGFiSW5kZXggPCAwICYmIGlzU2NvcGUgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgcmV0dXJuIHRhYkluZGV4O1xyXG59O1xyXG52YXIgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiBzb3J0T3JkZXJlZFRhYmJhYmxlcyhhLCBiKSB7XHJcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcclxufTtcclxudmFyIGlzSW5wdXQgPSBmdW5jdGlvbiBpc0lucHV0KG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xyXG59O1xyXG52YXIgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xyXG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XHJcbn07XHJcbnZhciBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHtcclxuICB2YXIgciA9IG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJztcclxuICB9KTtcclxuICByZXR1cm4gcjtcclxufTtcclxudmFyIGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIGdldENoZWNrZWRSYWRpbyhub2RlcywgZm9ybSkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcclxuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxudmFyIGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XHJcbiAgaWYgKCFub2RlLm5hbWUpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICB2YXIgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcclxuICB2YXIgcXVlcnlSYWRpb3MgPSBmdW5jdGlvbiBxdWVyeVJhZGlvcyhuYW1lKSB7XHJcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpO1xyXG4gIH07XHJcbiAgdmFyIHJhZGlvU2V0O1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgY29uc29sZS5lcnJvcignTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlcycsIGVyci5tZXNzYWdlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcclxuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcclxufTtcclxudmFyIGlzUmFkaW8gPSBmdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcclxuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XHJcbn07XHJcbnZhciBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkge1xyXG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XHJcbn07XHJcblxyXG4vLyBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cncyBkb2N1bWVudFxyXG52YXIgaXNOb2RlQXR0YWNoZWQgPSBmdW5jdGlvbiBpc05vZGVBdHRhY2hlZChub2RlKSB7XHJcbiAgdmFyIF9ub2RlUm9vdDtcclxuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXHJcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXHJcbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XHJcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcclxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXHJcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXHJcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcclxuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXHJcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxyXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcclxuICAvLyAgdGVzdGVkKS5cclxuICAvLyBUbyBmdXJ0aGVyIGNvbXBsaWNhdGUgdGhpbmdzLCB3ZSBoYXZlIHRvIGxvb2sgYWxsIHRoZSB3YXkgdXAgdW50aWwgd2UgZmluZCBhIHNoYWRvdyBIT1NUXHJcbiAgLy8gIHRoYXQgaXMgYXR0YWNoZWQgKG9yIGZpbmQgbm9uZSkgYmVjYXVzZSB0aGUgbm9kZSBtaWdodCBiZSBpbiBuZXN0ZWQgc2hhZG93cy4uLlxyXG4gIC8vIElmIHJvb3ROb2RlIGlzIG5vdCBhIHNoYWRvdyByb290LCBpdCB3b24ndCBoYXZlIGEgaG9zdCwgYW5kIHNvIHJvb3ROb2RlIHNob3VsZCBiZSB0aGVcclxuICAvLyAgZG9jdW1lbnQgKHBlciB0aGUgZG9jcykgYW5kIHdoaWxlIGl0J3MgYSBEb2N1bWVudC10eXBlIG9iamVjdCwgdGhhdCBkb2N1bWVudCBkb2VzIG5vdFxyXG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXHJcbiAgLy8gIHRvIGlnbm9yZSB0aGUgcm9vdE5vZGUgYXQgdGhpcyBwb2ludCwgYW5kIHVzZSBgbm9kZS5vd25lckRvY3VtZW50YC4gT3RoZXJ3aXNlLFxyXG4gIC8vICB1c2luZyBgcm9vdE5vZGUuY29udGFpbnMobm9kZSlgIHdpbGwgX2Fsd2F5c18gYmUgdHJ1ZSB3ZSdsbCBnZXQgZmFsc2UtcG9zaXRpdmVzIHdoZW5cclxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cclxuICAvLyBOT1RFOiBJZiBgbm9kZVJvb3RIb3N0YCBvciBgbm9kZWAgaGFwcGVucyB0byBiZSB0aGUgYGRvY3VtZW50YCBpdHNlbGYgKHdoaWNoIGlzIHBvc3NpYmxlXHJcbiAgLy8gIGlmIGEgdGFiYmFibGUvZm9jdXNhYmxlIG5vZGUgd2FzIHF1aWNrbHkgYWRkZWQgdG8gdGhlIERPTSwgZm9jdXNlZCwgYW5kIHRoZW4gcmVtb3ZlZFxyXG4gIC8vICBmcm9tIHRoZSBET00gYXMgaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC1yZWFjdC9pc3N1ZXMvOTA1KSwgdGhlblxyXG4gIC8vICBgb3duZXJEb2N1bWVudGAgd2lsbCBiZSBgbnVsbGAsIGhlbmNlIHRoZSBvcHRpb25hbCBjaGFpbmluZyBvbiBpdC5cclxuICB2YXIgbm9kZVJvb3QgPSBub2RlICYmIGdldFJvb3ROb2RlKG5vZGUpO1xyXG4gIHZhciBub2RlUm9vdEhvc3QgPSAoX25vZGVSb290ID0gbm9kZVJvb3QpID09PSBudWxsIHx8IF9ub2RlUm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Lmhvc3Q7XHJcblxyXG4gIC8vIGluIHNvbWUgY2FzZXMsIGEgZGV0YWNoZWQgbm9kZSB3aWxsIHJldHVybiBpdHNlbGYgYXMgdGhlIHJvb3QgaW5zdGVhZCBvZiBhIGRvY3VtZW50IG9yXHJcbiAgLy8gIHNoYWRvdyByb290IG9iamVjdCwgaW4gd2hpY2ggY2FzZSwgd2Ugc2hvdWxkbid0IHRyeSB0byBsb29rIGZ1cnRoZXIgdXAgdGhlIGhvc3QgY2hhaW5cclxuICB2YXIgYXR0YWNoZWQgPSBmYWxzZTtcclxuICBpZiAobm9kZVJvb3QgJiYgbm9kZVJvb3QgIT09IG5vZGUpIHtcclxuICAgIHZhciBfbm9kZVJvb3RIb3N0LCBfbm9kZVJvb3RIb3N0JG93bmVyRG8sIF9ub2RlJG93bmVyRG9jdW1lbnQ7XHJcbiAgICBhdHRhY2hlZCA9ICEhKChfbm9kZVJvb3RIb3N0ID0gbm9kZVJvb3RIb3N0KSAhPT0gbnVsbCAmJiBfbm9kZVJvb3RIb3N0ICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3Qkb3duZXJEbyA9IF9ub2RlUm9vdEhvc3Qub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdCRvd25lckRvICE9PSB2b2lkIDAgJiYgX25vZGVSb290SG9zdCRvd25lckRvLmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHwgbm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSB2b2lkIDAgJiYgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlJG93bmVyRG9jdW1lbnQgIT09IHZvaWQgMCAmJiBfbm9kZSRvd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpKTtcclxuICAgIHdoaWxlICghYXR0YWNoZWQgJiYgbm9kZVJvb3RIb3N0KSB7XHJcbiAgICAgIHZhciBfbm9kZVJvb3QyLCBfbm9kZVJvb3RIb3N0MiwgX25vZGVSb290SG9zdDIkb3duZXJEO1xyXG4gICAgICAvLyBzaW5jZSBpdCdzIG5vdCBhdHRhY2hlZCBhbmQgd2UgaGF2ZSBhIHJvb3QgaG9zdCwgdGhlIG5vZGUgTVVTVCBiZSBpbiBhIG5lc3RlZCBzaGFkb3cgRE9NLFxyXG4gICAgICAvLyAgd2hpY2ggbWVhbnMgd2UgbmVlZCB0byBnZXQgdGhlIGhvc3QncyBob3N0IGFuZCBjaGVjayBpZiB0aGF0IHBhcmVudCBob3N0IGlzIGNvbnRhaW5lZFxyXG4gICAgICAvLyAgaW4gKGkuZS4gYXR0YWNoZWQgdG8pIHRoZSBkb2N1bWVudFxyXG4gICAgICBub2RlUm9vdCA9IGdldFJvb3ROb2RlKG5vZGVSb290SG9zdCk7XHJcbiAgICAgIG5vZGVSb290SG9zdCA9IChfbm9kZVJvb3QyID0gbm9kZVJvb3QpID09PSBudWxsIHx8IF9ub2RlUm9vdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlUm9vdDIuaG9zdDtcclxuICAgICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdDIgPSBub2RlUm9vdEhvc3QpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3QyJG93bmVyRCA9IF9ub2RlUm9vdEhvc3QyLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRCAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRC5jb250YWlucyhub2RlUm9vdEhvc3QpKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGF0dGFjaGVkO1xyXG59O1xyXG52YXIgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIGlzWmVyb0FyZWEobm9kZSkge1xyXG4gIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgd2lkdGggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUud2lkdGgsXHJcbiAgICBoZWlnaHQgPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUuaGVpZ2h0O1xyXG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XHJcbn07XHJcbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uIGlzSGlkZGVuKG5vZGUsIF9yZWYpIHtcclxuICB2YXIgZGlzcGxheUNoZWNrID0gX3JlZi5kaXNwbGF5Q2hlY2ssXHJcbiAgICBnZXRTaGFkb3dSb290ID0gX3JlZi5nZXRTaGFkb3dSb290O1xyXG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XHJcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcclxuICAvLyAgKHRoaXMgaXMgbGVnYWN5IGJlaGF2aW9yIGZyb20gYSB2ZXJ5IGxvbmcgd2F5IGJhY2spXHJcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXHJcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXHJcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICB2YXIgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xyXG4gIHZhciBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcclxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2xlZ2FjeS1mdWxsJykge1xyXG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZSBub2RlIHRvIGJlIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyBhbmQgdXNlIHRoZVxyXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXHJcbiAgICAgIHZhciBvcmlnaW5hbE5vZGUgPSBub2RlO1xyXG4gICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciByb290Tm9kZSA9IGdldFJvb3ROb2RlKG5vZGUpO1xyXG4gICAgICAgIGlmIChwYXJlbnRFbGVtZW50ICYmICFwYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QgJiYgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSAvLyBjaGVjayBpZiB0aGVyZSdzIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gbm9kZSBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHdoaWNoIG1lYW5zIHdlIGNhbiBvbmx5IHRyZWF0IGl0IGFzIGEgYmxhY2sgYm94LCBzbyB3ZVxyXG4gICAgICAgICAgLy8gIGZhbGwgYmFjayB0byBhIG5vbi16ZXJvLWFyZWEgdGVzdFxyXG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xyXG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBzbG90XHJcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XHJcbiAgICAgICAgfSBlbHNlIGlmICghcGFyZW50RWxlbWVudCAmJiByb290Tm9kZSAhPT0gbm9kZS5vd25lckRvY3VtZW50KSB7XHJcbiAgICAgICAgICAvLyBjcm9zcyBzaGFkb3cgYm91bmRhcnlcclxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIG5vcm1hbCBkb21cclxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xyXG4gICAgfVxyXG4gICAgLy8gZWxzZSwgYGdldFNoYWRvd1Jvb3RgIG1pZ2h0IGJlIHRydWUsIGJ1dCBhbGwgdGhhdCBkb2VzIGlzIGVuYWJsZSBzaGFkb3cgRE9NIHN1cHBvcnRcclxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcclxuICAgIC8vICBpdCBtaWdodCBiZSBhIGZhbHN5IHZhbHVlLCB3aGljaCBtZWFucyBzaGFkb3cgRE9NIHN1cHBvcnQgaXMgZGlzYWJsZWRcclxuXHJcbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXHJcbiAgICAvLyAgbm93IHdlIGNhbiBqdXN0IHRlc3QgdG8gc2VlIGlmIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHZpc2libGUgb3Igbm90LCBwcm92aWRlZCBpdCdzXHJcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXHJcbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xyXG4gICAgLy8gIGBpc1RhYmJhYmxlKClgIG9yIGBpc0ZvY3VzYWJsZSgpYCAtLSByZWdhcmRsZXNzIG9mIGBnZXRTaGFkb3dSb290YCBvcHRpb24gc2V0dGluZy5cclxuXHJcbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcclxuICAgICAgLy8gdGhpcyB3b3JrcyB3aGVyZXZlciB0aGUgbm9kZSBpczogaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgY2xpZW50IHJlY3QsIGl0J3NcclxuICAgICAgLy8gIHNvbWVob3cgZGlzcGxheWVkOyBpdCBhbHNvIGNvdmVycyB0aGUgQ1NTICdkaXNwbGF5OiBjb250ZW50cycgY2FzZSB3aGVyZSB0aGVcclxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXHJcbiAgICAgIC8vICB1cCB0aGUgaGllcmFyY2h5IGVpdGhlclxyXG4gICAgICByZXR1cm4gIW5vZGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRWxzZSwgdGhlIG5vZGUgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGUgYGdldENsaWVudFJlY3RzKClgXHJcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcclxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxyXG4gICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTExNyNpc3N1ZWNvbW1lbnQtMjg0MjI4ODcwKVxyXG4gICAgLy9cclxuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcclxuICAgIC8vICBiZWNhdXNlIHN0eWxlcyBhcmUgb25seSBjb21wdXRlZCBmb3Igbm9kZXMgdGhhdCBhcmUgaW4gdGhlIGRvY3VtZW50LlxyXG4gICAgLy9cclxuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXHJcbiAgICAvLyAgc29tZWhvdy4gVGhvdWdoIGl0IHdhcyBuZXZlciBzdGF0ZWQgb2ZmaWNpYWxseSwgYW55b25lIHdobyBoYXMgZXZlciB1c2VkIHRhYmJhYmxlXHJcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxyXG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxyXG4gICAgLy8gIGNvbnNpZGVyaW5nIF9fZXZlcnl0aGluZ19fIHRvIGJlIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgaW5uYWJpbGl0eSB0byBkZXRlcm1pbmUgc3R5bGVzLlxyXG4gICAgLy9cclxuICAgIC8vIHY2LjAuMDogQXMgb2YgdGhpcyBtYWpvciByZWxlYXNlLCB0aGUgZGVmYXVsdCAnZnVsbCcgb3B0aW9uIF9fbm8gbG9uZ2VyIHRyZWF0cyBkZXRhY2hlZFxyXG4gICAgLy8gIG5vZGVzIGFzIHZpc2libGUgd2l0aCB0aGUgJ25vbmUnIGZhbGxiYWNrLl9fXHJcbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyBoaWRkZW5cclxuICAgIH1cclxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXHJcbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xyXG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXHJcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXHJcbiAgICAvLyAgY2xpZW50IHJlY3QsIHdlIGRvbid0IHNwZWNpYWwtY2FzZSBmb3Igd2hldGhlciB0aGUgbm9kZSBpcyBhdHRhY2hlZCBvciBub3QuIEluXHJcbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXHJcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cclxuICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrPW5vbmVgIG1vZGUsIHdlIGFzc3VtZVxyXG4gIC8vICBpdCdzIHZpc2libGVcclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxyXG4vLyAgdW5sZXNzIHRoZXkgYXJlIGluIHRoZSBfZmlyc3RfIDxsZWdlbmQ+IGVsZW1lbnQgb2YgdGhlIHRvcC1tb3N0IGRpc2FibGVkXHJcbi8vICBmaWVsZHNldFxyXG52YXIgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSkge1xyXG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxyXG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcclxuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XHJcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpO1xyXG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxyXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChwYXJlbnROb2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdIConKSA/IHRydWUgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+IGNvbnRhaW5pbmcgYG5vZGVgIGhhcyBubyA8bGVnZW5kPlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBlbHNlLCBub2RlJ3MgdGFiYmFibGUvZm9jdXNhYmxlIHN0YXRlIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgYSBmaWVsZHNldCdzXHJcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSB7XHJcbiAgaWYgKG5vZGUuZGlzYWJsZWQgfHxcclxuICAvLyB3ZSBtdXN0IGRvIGFuIGluZXJ0IGxvb2sgdXAgdG8gZmlsdGVyIG91dCBhbnkgZWxlbWVudHMgaW5zaWRlIGFuIGluZXJ0IGFuY2VzdG9yXHJcbiAgLy8gIGJlY2F1c2Ugd2UncmUgbGltaXRlZCBpbiB0aGUgdHlwZSBvZiBzZWxlY3RvcnMgd2UgY2FuIHVzZSBpbiBKU0RvbSAoc2VlIHJlbGF0ZWRcclxuICAvLyAgbm90ZSByZWxhdGVkIHRvIGBjYW5kaWRhdGVTZWxlY3RvcnNgKVxyXG4gIGlzSW5lcnQobm9kZSkgfHwgaXNIaWRkZW5JbnB1dChub2RlKSB8fCBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fFxyXG4gIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xyXG4gIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHx8IGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSkge1xyXG4gIGlmIChpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiSW5kZXgobm9kZSkgPCAwIHx8ICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG52YXIgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUoc2hhZG93SG9zdE5vZGUpIHtcclxuICB2YXIgdGFiSW5kZXggPSBwYXJzZUludChzaGFkb3dIb3N0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcclxuICBpZiAoaXNOYU4odGFiSW5kZXgpIHx8IHRhYkluZGV4ID49IDApIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICAvLyBJZiBhIGN1c3RvbSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSB0YWJpbmRleCxcclxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZVNjb3BlPn0gY2FuZGlkYXRlc1xyXG4gKiBAcmV0dXJucyBFbGVtZW50W11cclxuICovXHJcbnZhciBzb3J0QnlPcmRlciA9IGZ1bmN0aW9uIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpIHtcclxuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xyXG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XHJcbiAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XHJcbiAgICB2YXIgaXNTY29wZSA9ICEhaXRlbS5zY29wZVBhcmVudDtcclxuICAgIHZhciBlbGVtZW50ID0gaXNTY29wZSA/IGl0ZW0uc2NvcGVQYXJlbnQgOiBpdGVtO1xyXG4gICAgdmFyIGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0U29ydE9yZGVyVGFiSW5kZXgoZWxlbWVudCwgaXNTY29wZSk7XHJcbiAgICB2YXIgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XHJcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcclxuICAgICAgaXNTY29wZSA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaC5hcHBseShyZWd1bGFyVGFiYmFibGVzLCBlbGVtZW50cykgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xyXG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXHJcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxyXG4gICAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcclxuICAgICAgICBjb250ZW50OiBlbGVtZW50c1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29ydGFibGUpIHtcclxuICAgIHNvcnRhYmxlLmlzU2NvcGUgPyBhY2MucHVzaC5hcHBseShhY2MsIHNvcnRhYmxlLmNvbnRlbnQpIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIFtdKS5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XHJcbn07XHJcbnZhciB0YWJiYWJsZSA9IGZ1bmN0aW9uIHRhYmJhYmxlKGNvbnRhaW5lciwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHZhciBjYW5kaWRhdGVzO1xyXG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcclxuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2NvbnRhaW5lcl0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xyXG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxyXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcclxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxyXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoY29udGFpbmVyLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpKTtcclxuICB9XHJcbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xyXG59O1xyXG52YXIgZm9jdXNhYmxlID0gZnVuY3Rpb24gZm9jdXNhYmxlKGNvbnRhaW5lciwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHZhciBjYW5kaWRhdGVzO1xyXG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcclxuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2NvbnRhaW5lcl0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xyXG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcclxuICAgICAgZmxhdHRlbjogdHJ1ZSxcclxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoY29udGFpbmVyLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSk7XHJcbiAgfVxyXG4gIHJldHVybiBjYW5kaWRhdGVzO1xyXG59O1xyXG52YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUobm9kZSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIGlmICghbm9kZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XHJcbiAgfVxyXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpO1xyXG59O1xyXG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XHJcbnZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBpZiAoIW5vZGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xyXG4gIH1cclxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XHJcbn07XHJcblxyXG5leHBvcnQgeyBmb2N1c2FibGUsIGdldFRhYkluZGV4LCBpc0ZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgdGFiYmFibGUgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/tabbable/dist/index.esm.js\n");

/***/ })

};
;